(function() {
    "use strict";

    function createOptions(options, value) {
        var strOptions = '';
        if (options) {
            for (var i = 0; i < options.length; i++) {
                strOptions += '<option value="' + options[i].value + '"'+(options[i].value==value ? ' selected' : '')+'>' + options[i].text + '</option>';
            }
        }
        return strOptions;
    }

    tinymce.ui.SelectBoxWithValues = tinymce.ui.Widget.extend({
        Defaults: {
            classes: "selectbox",
            role: "selectboxwithvalues",
            options: [],
            value: null
        },
        /**
         * Constructs a instance with the specified settings.
         *
         * @constructor
         * @param {Object} settings Name/value object with settings.
         * @setting {Array} options Array with options to add to the select box.
         */
        init: function(settings) {
            var self = this;

            self._super(settings);

            if (self.settings.size) {
                self.size = self.settings.size;
            }

            if (self.settings.options) {
                self._options = self.settings.options;
            }

            if(self.settings.value !== undefined) {
                self._value = self.settings.value;
            }

            self.on('keydown', function(e) {
                var rootControl;

                if (e.keyCode == 13) {
                    e.preventDefault();

                    // Find root control that we can do toJSON on
                    self.parents().reverse().each(function(ctrl) {
                        if (ctrl.toJSON) {
                            rootControl = ctrl;
                            return false;
                        }
                    });

                    // Fire event on current text box with the serialized data of the whole form
                    self.fire('submit', {data: rootControl.toJSON()});
                }
            });

            self.on('input',function(e) {
                self.state.set('value', e.target.value);
            });
        },

        /**
         * Getter/setter function for the options state.
         *
         * @method options
         * @param {Array} [state] State to be set.
         * @return {Array|tinymce.ui.SelectBox} Array of string options.
         */
        options: function(state) {
            if (!arguments.length) {
                return this.state.get('options');
            }

            this.state.set('options', state);

            return this;
        },

        renderHtml: function() {
            var self = this, options, size = '';

            options = createOptions(self._options, self._value);

            if (self.size) {
                size = ' size = "' + self.size + '"';
            }

            return (
                    '<select id="' + self._id + '" class="' + self.classes + '"' + size + '>' +
                    options +
                    '</select>'
                   );
        },

        bindStates: function() {
            var self = this;

            self.state.on('change:options', function(e) {
                self.getEl().innerHTML = createOptions(e.value, self._value);
            });

            return self._super();
        }
    });

    tinymce.ui.Factory.add('selectboxwithvalues',tinymce.ui.SelectBoxWithValues)
})();

tinymce.PluginManager.add('gapfill', function(editor) {

    var gaps = null;

    function gapfillHTML(n) {
        return '<gapfill class="mceNonEditable" data-number="'+n+'">Gap '+n+'</gapfill>'
    }
    function gapfillText(n) {
        return '[['+n+']]';
    }

    function name_for_gap(n) {
        if(gaps && gaps[n] && gaps[n].name()) {
            return gaps[n].name();
        } else {
            return 'Gap '+n;
        }
    }

    function set_gap_content(g) {
        var n = parseInt(g.getAttribute('data-number'));
        g.textContent = name_for_gap(n);
    }

    function update_gaps() {
        editor.dom.select('gapfill').map(set_gap_content);
    }

    editor.replaceGapfills = function(content) {
        return content.replace(/\[\[(\d+)\]\]/g,function(m,n) {
            return gapfillHTML(n);
        });
    }
    editor.restoreGapfills = function(content) {
        return content.replace(/<gapfill class="mceNonEditable" data-number="(\d+)">.*?<\/gapfill>/g,function(t,n) {
            return gapfillText(n);
        });
    }

    editor.on('BeforeSetcontent', function(evt){ 
        evt.content = editor.replaceGapfills( evt.content );
    });
    editor.on('Setcontent', function(evt){ 
        update_gaps();
    });

    editor.on('GetContent', function(evt){
        if(!evt.keepGapfills) {
            evt.content = editor.restoreGapfills(evt.content);
        }
    });

    function promptGapNumber(callback,value) {
        editor.windowManager.open({
            title: 'Gapfill',
            body: [
                {type: 'selectboxwithvalues', name: 'n', label: 'Gap', options: gaps.map(function(g,i) { return {text: name_for_gap(i), value: i}; }), value: value}
            ],
            onsubmit: function(e) {
                var n = e.data.n;
                if(!isNaN(n)) {
                    n = parseInt(n);
                    callback(n);
                }
            }
        });
    }

    function insertGapfill(ui,val) {
        var gapfills = editor.dom.select('gapfill');
        var max = null;
        var ns = [];
        gapfills.map(function(g) {
            var n = parseInt(g.getAttribute('data-number'));
            if(!isNaN(n)) {
                ns.push(n);
            }
        });
        var max = 0;
        ns.sort();
        ns.forEach(function(n) {
            if(n==max) {
                max += 1;
            }
        });
        promptGapNumber(function(n) {
            editor.execCommand('mceInsertContent',true,gapfillHTML(n));
            update_gaps();
        },max+'');
    }

    function changeGapfill(node) {
        promptGapNumber(function(n) {
            node.setAttribute('data-number', n);
            set_gap_content(node);
        },node.getAttribute('data-number'));
    }

    editor.addMenuItem('gapfill', {
        shortcut: 'Alt+G',
        text: 'Insert gap',
        onclick: insertGapfill,
        context: 'insert',
        prependToContext: true,
        onpostrender: function() {
            var menu_item = this;
            editor.on('toggle_gapfill_button',function(e) {
                menu_item.disabled(!e.show);
            });
        }
    });

    editor.addButton('gapfill', {
        shortcut: 'Alt+G',
        classes: 'widget btn gapfill',
        text: 'G',
        tooltip: 'Insert gap',
        onclick: insertGapfill,
        onpostrender: function() {
            var btn = this;
            editor.on('toggle_gapfill_button',function(e) {
                btn.disabled(!e.show);
            });
        }
    });

    editor.on('gaps_changed',function(new_gaps) {
        if(gaps) {
            var lowest_unseen = 0;
            var positions = {};
            for(var i=0;i<gaps.length;i++) {
                var j = new_gaps.indexOf(gaps[i]);
                if(j>=0) {
                    positions[i] = j;
                    if(j==lowest_unseen) {
                        lowest_unseen = j+1;
                    }
                }
            }
            editor.dom.select('gapfill').map(function(g) {
                var n = parseInt(g.getAttribute('data-number'));
                var nn = positions[n]===undefined ? lowest_unseen : positions[n];
                g.setAttribute('data-number', nn);
            });
        }
        gaps = new_gaps.slice();
        update_gaps();
        editor.execCommand('mceInsertContent',true,'');
    });

    editor.addShortcut('Alt+G','Insert gap',insertGapfill);

    editor.addCommand('insertGapfill', insertGapfill);

    editor.on('DblClick',function(e) {
        if(e.target.nodeName.toLowerCase()=='gapfill') {
            changeGapfill(e.target);
        }
    });
});
